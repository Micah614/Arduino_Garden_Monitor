<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="javascript.js"></script>

    <title>
        Arduino Project Board Tutorial Summaries
    </title>
</head>
<body>
    <h1>
        Arduino Tutorials
    </h1>
    <!--Page Summary-->
    <p>
        Welcome to the Arduino mini-project and tutorial page. 
        
        This page includes tutorial documentation with photos, data, and Arduino source code. Each tutorial 
        section described in the summaries below describes skills and knowledge that was acquired to 
        complete the larger project of building an IOT-integrated device and REST API platform at a URL 
        related at this website. 

        Each entry in this table below outlines an experiment or observation involving single board computer 
        parts and Arduino packaged firmware. Working materials include sensors, switches, buttons, LEDs, 
        continuous control knobs, joystick, and RFID field detector, to name a few. Some of these projects are 
        from the tutorial guide, others might be designed by me. Check out the 
        <a href="./greenhouse_monitor_project.html" class="">WiFi Greenhouse Monitor and REST API Project</a> 
        for more Arduino madness!
    </p>
        

    <!--Weekly Timeline Table-->
    <table style="width:100%">
        <caption>
            Click a link in the "Time Period" column to read about that week's activities.
        </caption>
        <tr>
            <th scope="col">Time Period</th>
            <th scope="col">Activity Summary</th>
        </tr>
        <!-- Start of weekly update format-->
        <tr>
            <th scope="row">
                <a href="#week_1_and_2">
                    Week 1 and 2
                </a>
            </th>
            <td>
                <p>
                    Week one was spent defining an idea for the semester project. 
                    For more information visit the <a href="./proposal.html">Project Proposal.</a> webpage.
                </p>
                <p>
                    Week two was mainly spent developing the project proposal and starting a GitHub website URL 
                    for the semester project. I also completed the first 4 chapters of the Arduino 
                    Project Board Tutorial.
                </p>
            </td>
        </tr>
        <!-- End of weekly update format unit-->>
        <tr>
            <th scope="row">
                <a href="#week_3">
                    Week 3
                </a>
            </th>
            <td>
                In week three, I extended the project website by 3 more pages and inserted links between 
                the pages of the site. I also completed additional Arduino Project Board tutorial challenges.
            </td>
        </tr>
    </table>
    <!-- End of the inner-page navigation menu table-->


    <hr> <!-- BEGIN WEEK 1 + 2 -->

    <!-- Start of Weekly Summaries-->
    <div> <!-- Save this div for CSS formatting. -->
        <h4 id="week_1_and_2">
            Week 1+2: Start a GitHub Pages Website, Start Tutorial, Develop and Submit a Proposal
        </h4>
        <p>
            A large part of week 1+2 was spent developing the project proposal and crafting a project timeline. 
            Early chapters of the project board tutorial (completed in week 2) explain the basics of the Arduino 
            integrated development environment (IDE), as well as how to create, compile, push and test Arduino 
            firmware.

            The project board tutorial explains the basic concepts of driver functions, including the roles of 
            the setup() and loop() driver methods and how to use system calls to control and communicate with 
            prototype electronics via comm. hubs, electrical circuits, and free-range communication exchange 
            media (e.g., infrared, RFID, etc.).
            
            The Arduino IDE software provides a feature rich and intuitive development platform. The set up 
            involves a simple download from the official Arduino website, and choosing a folder to contain future 
            source files. The only pitfall that I encountered during this set up was an apparent incompatibility 
            of Arduino IDE generated files and the GitHub repository stored on my local computer. According to 
            the generated error messages, the GitHub repository on my local computer creates an environment that 
            is too complex for the Arduino IDE to interact with. While investigating this finding, I observed 
            that each sketch (another term for an Arduino source file) generates a number of dependency files 
            during compile time, producing a "bloat ratio" in the range of 2-3 new files for each new sketch. 
            GitHub compatiblity issues aside, the IDE software provides a great list of features including a 
            file manager, terminal shell, and editor.
            
            Programming in the Arduino dialect of C++ involves a mixture of object-oriented programming, 
            development of sys- and trap- calls, and tactful use of Arduino-defined function stems, including 
            "setup()", "loop()", and "digitalWrite()". Arduino developers are free to define helper functions of 
            any kind, subject only to the hardware constraints of the single-board the firmware is loaded on. 
        </p>

        <img src="./Images/Arduino_IDE.png"> <br> 

        <p>
            <strong>Figure 1.)</strong> Snapshot of the Arduino integrated development environment (IDE).
        </p>
        <h5>
            Chapters 1: LED Blink
        </h5>
        <p>
            Chapter one of this tutorial explains the concept of converting analog to digital signals. The 
            chapter describes the LED circuit and the role of the "setup()", "loop()", "delay()" and 
            "digitalWrite()" functions in firmware. Each of these principles is demostrated through a 
            firmware program designed to drive a blinking LED.
            
            <b>Sketch: LED_Blink</b> <br> 
            <b>/* Chapter 1 */</b> <br> 
            // the setup function runs once when you press reset or power the board <br> 
            void setup() { <br> 
              // initialize digital pin 13 as an output <br> 
              pinMode(13, OUTPUT); <br> 
            } <br> 
            // the loop function runs over and over again forever <br> 
            void loop() { <br> 
              digitalWrite(13, HIGH); // turn the LED on (HIGH is the voltage level) <br> 
              delay(1000); // wait for a second <br> 
              digitalWrite(13, LOW); // turn the LED off by making the voltage LOW <br> 
              delay(1000); // wait for a second <br> 
            } <br> 
        </p>

        <h5>
            Chapter 2: Flowing LED
        </h5>
        <p>
            Chapter 2 of this material demonstrates the object-oriented nature of firmware development by using 
            loops and basic data structures (i.e., arrays) to synchronize and control circuits of electronic 
            devices, in this case, a panel of LEDs.
            
            <b>Sketch: Flowing_LED_Display</b> <br> 
            <b>/* Chapter 2 */</b> <br> 
            const int ledCount = 14; // the number of LEDs <br> 
            // an array of pin numbers to which LEDs are attached <br> 
            int ledPins[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }; <br> 
            void setup() { <br> 
              // loop over the pin array and set them all to output: <br> 
              for (int i = 0; i < ledCount; i++) { <br> 
                pinMode(ledPins[i], OUTPUT); <br> 
              } <br> 
            } <br> 
            void loop() { <br> 
              // the ith LED will light up in turn <br> 
              for (int i = 0; i < ledCount; i++) { <br> 
                barGraphDisplay(i); <br> 
              } <br> 
              for (int i = ledCount-1; i >=0; i--) { <br> 
                barGraphDisplay(i); <br> 
              } <br> 
            } <br> 
            void barGraphDisplay(int ledOn) { <br> 
              // make the "ledOn"th LED on and the others off <br> 
              for (int i = 0; i < ledCount; i++) { <br> 
                if (i == ledOn) <br> 
                  digitalWrite(ledPins[i], HIGH); <br> 
                else <br> 
                  digitalWrite(ledPins[i], LOW); <br> 
              } <br> 
              delay(100); <br> 
            } <br> 
        </p>

        <h5>
            Chapter 3: Control LED with a Push Button Switch
        </h5>
        <p>
            Chapter 3 of this tutorial explains the circuit fundamentals of controlling circuit behavior with a 
            button-based switch. 
            
            <img src="./Images/button_circuit_diagram.svg"> <br> 
            <strong>Figure 2.)</strong> A diagram of a button-controlled circuit. <br> 
            <img src="./Images/project_board_schematic.svg"> <br> 
            <strong>Figure 3.)</strong> Control state of the project board. (IDE). <br> 

            The first sub-section of this chapter discusses how the voltage state of the circuit in figure 3 
            can be encoded as a meaningful signal state by applying the firmware to the control board set to 
            the configuration shown in figure 3. <br> 

            <b>Sketch: Control_LED_by_Button</b> <br> 
            <b>/* Chapter 3 - mini-project 1 */</b> <br> 
            /* This sketch maps the voltage detected on a closed circuit created by the button to an 
               LED ON state that persists as long as the button is held down. */ <br> 
            int buttonPin = 2; // the number of the push button pin <br> 
            int ledPin = 13; // the number of the LED pin <br> 
            void setup() { <br> 
              pinMode(buttonPin, INPUT); // set push button pin into input mode. (says "read the signal here.") <br> 
              pinMode(ledPin, OUTPUT); // set LED pin into output mode. (says "affect the cicuit component at this location.") <br> 
            } <br> 
            void loop() { <br> 
              if (digitalRead(buttonPin) == HIGH) // if the button is not pressed <br> 
                digitalWrite(ledPin, LOW); // switch off LED <br> 
              else // if the button is pressed <br> 
                digitalWrite(ledPin, HIGH); // switch on LED <br> 
            } <br> 

            The second sketch design maintains the "ON" or "OFF" state of the LED subcircuit until the button 
            is pressed again. This is commonly referred to as programming a "persistant state" in the controller. 
            Included in the circuit knowledge of this chapter is a discussion about controlling "bounce" in 
            electrical cicuits. Bounce is a phenomena created by micro-imbalances in the electrical signal prior 
            to achieving a maintainable state. Controlling bounce essentially involves inoking a delay prior to 
            the interpretation of an electrical state signal. If bounce is left uncontrolled by the device 
            firmware, the state of the controlling device (i.e., button) is read during a period of oscillation, 
            causing the firmware to react rapidly to the perceived ON/OFF state detected in the circuit. <br> <br> 

            We can see how this sleep()-like system call is applied in the driver firmware by reading the sketch 
            code snippet below. <br> 

            <b>Sketch: Control_LED_State_by_Button</b> <br> 
            <b>/* Chapter 3 - mini-project 2 */</b> <br> 
            int buttonPin = 2; // the number of the push button pin <br> 
            int ledPin = 13; // the number of the LED pin <br> 
            boolean isLighting = false; // define a variable to save the state of LED <br> 
            void setup() { <br> 
              pinMode(buttonPin, INPUT); // set push button pin into input mode <br> 
              pinMode(ledPin, OUTPUT); // set LED pin into output mode <br> 
            } <br> 
            void loop() { <br> 
              if (digitalRead(buttonPin) == LOW) { // if the button is pressed <br> 
                delay(10); // delay for a certain time to skip the bounce <br> 
                if (digitalRead(buttonPin) == LOW) { // confirm again if the button is pressed <br> 
                  reverseLED(); // reverse LED <br> 
                  while (digitalRead(buttonPin) == LOW); // wait for releasing <br> 
                    delay(10); // delay for a certain time to skip bounce when the button is released <br> 
                } <br> 
              } <br> 
            } <br> 
            void reverseLED() { <br> 
              if (isLighting) { // if LED is lighting, <br> 
                digitalWrite(ledPin, LOW); // switch off LED <br> 
                isLighting = false; // store the state of LED <br> 
              } <br> 
              else { // if LED is off, <br> 
                digitalWrite(ledPin, HIGH); // switch LED <br> 
                isLighting = true; // store the state of LED <br> 
              } <br> 
            } <br>  <br> 
        </p>
        
        <hr> <!-- BEGIN CHAPTER 4 -->

        <h5>
            Chapter 4: Sending/Receiving Data Through a Serial Communication Port (AKA "Comm. Port")
        </h5>
        <p>
            Chapter 4 discusses 


        </p>
    </div>

    <hr> <!-- BEGIN WEEK 3 -->

    <div>  <!-- Save this div for CSS formatting. -->
        <h4 id="week_3">
            Week 3: Extend the Project Website, Complete Project Board Tutorials
        </h4>
        <h5>
            Week 3 Summary: Tutorials
        </h5>
        <p>
            This week's tutorial lesson explained how to establish a serial connection and shared communication frequency 
            (i.e., Baud rate) between communicating devices. The code knowledge in this section explains the role of interruption 
            programs (e.g., trap-outs and system calls) in gathering asynchronous feedback from connected/controlled devices. The 
            following block quote from the tutorial provides a good analogy for the subject: <br> 
            <blockquote>
                ...suppose you're watching TV while there is water heating in your kitchen... (without a teakettle spout) you have to 
                check whether the water is boiling or not from time to time, so you can't concentrate on watching TV. But (with) an 
                interrupt, things (are) different. Interrupts work much like the lid on your teakettle, ... whistles when the water is 
                beginning to boil. ... (So) you can focus on watching TV ..."
            </blockquote>
            The role of the interrupt program is to allow the processor to facilitate the execution of as many tasks (or programs) as 
            possible while conserving computational resources.
        </p>    
        <h5>
            Chapter 5 - Analog-to-Digital Converters ("ADC"s) in Serial Communication
        </h5>
        <p>
            ADC is used to convert analog (the physical signal) signals into digital signals (the abstract 
            message being transmitted between electronic devices). This section of the tutorial 
            explains how this signal transformation is achieved.
        </p>

        <h5>
            Circuit Knowledge
        </h5>        
        <p> 
            An ADC is an electronic circuit used to convert analog signals such as voltage to 
            digital or binary format consisting of 0's and 1's. The range of the ADC module included in the 
            project board is 10 bits, which means the ADC circuit component carries a 2^10 = 1024 bit 
            resolution. This means that the ADC's voltage settings are evenly and reliably distributed into 
            1024 "discrete" voltages (ranging from 0 to 5V), each corresponding to a digital signal. 
        </p>
        <img src="./Images/ADC_Graph.png">
        <p>
            <strong>Figure 2.)</strong> A graphical explaination of the potentiometer-drived analog-to-digital 
            conversion, also called "ADC". The rotational potentiometer included in the project board 
            achieves 1024 unique states, each equating to a unique binary/digital output. Note the step-like 
            behavior of this function, revealing the discretized voltage ranges corresponding to each digital 
            output.
        </p>
        <p>
            This voltage setting is controlled with a circuit element called a "potentiometer", which is 
            essentially an adjustable resistor element. Potentiometers are typically controlled by a resistive 
            substance (e.g., a wire or a carbon element) and a contact brush. The resistance (and therefore 
            voltage) of the potentiometer changes depending on the placement of the contact brush. The position 
            of this contact brush is what provides the ADC with it's resolution capacity. The resistive surface 
            is divided into discrete stages for the contact brush to rest upon. It is the position of this brush 
            that effects the analog to digital signal transformation and determines the ADC's signal resolution.
        </p>
        
        <p>
            The potentiometer is the core electrical component of a turn dial knob, such as one might find in 
            an old car radio. In fact, these turn dials are sometimes called "rotary potentiometers", since they 
            really just linear potentiometers with the physical action mapped to a rotational range of 
            motion. Because each voltage must be mapped to a discrete digital signal, a calculation must be 
            included in the driver code to complete the analog-to-digital signal transformation. 
        </p>
        
        <h4>Experiment/Sketch:</h4>
        <p>
            This tutorial section demonstrates the core concepts of ADC by writing a program to read the 
            current voltage of a rotary potentiometer and send this data to the IDE Serial Monitor window 
            via a serial port connection (port 4, in this case). The following section is driver code 
            collected from the tutorial.
        </p>

        <p>
            ~~~~~~<br>
            int adcValue; // Define a variable to save ADC value<br>
            float voltage; // Define a variable to save the calculated voltage value<br>
            
            void setup() {<br>
            Serial.begin(9600); // Initialize the serial port and set the baud rate to 9600<br>
            }<br>
            
            void loop() {<br>
                adcValue = analogRead(A1); // Convert analog of pin A1 to digital<br>
                voltage = adcValue * (5.0 / 1023.0);// Calculate voltage according to digital. Discretizes voltage range into 1024 bins.<br>
                <br>
                // Send the result to computer through serial port.<br>
                Serial.print("convertValue:");<br>
                Serial.println(adcValue);  // convertValue ranges from 0 to 1023<br>

                Serial.print("Voltage:");<br>
                Serial.println(voltage);  // <br>
                delay(500);  # delay between signal transmission (keeps the screen serial monitor from expanding uncontrollably)<br>
            }<br>
            ~~~~~~<br>
        </p>

        <hr> <!-- BEGIN WEEK 4 -->

        <h4 id="week_4">
            Week 4: Extend the Project Website, Complete Project Board Tutorials
        </h4>
        <h5>
            Week 4 Summary: Tutorial Chapter 6 - RGB LED
        </h5>
        <p>
            Week 4 covered project board tutorial chapter 6, which includes a fun mini-project to control a 3-color LED using a 
            3-knob potentiometer. The idea is that the different colors of light mix together, emitting a special color.
        </p>   
        <h5>
            Week 4 Summary: Project Research
        </h5>
        <p>
            This week I investigated the software methods and hardware that I will require to set up a REST API end-point for the 
            Arduino Weatherstation that I will be constructing in the upcoming weeks. Several options exist for hosting an endpoint 
            from an arduino device. Arduino ESP8266 is a WiFi transciever chip that is the base component needed to build and host an 
            REST API from a custom webserver! See the video below for more details. <br>

            <iframe width="560" height="315" src="https://www.youtube.com/embed/dWM4p_KaTHY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </p>

        <hr> <!-- BEGIN WEEK 5 -->

        <h4 id="week_5">
            Week 5: Extend the Project Website, Complete Project Board Tutorials
        </h4>
        <h5>
            Week 5 Summary: Tutorials
        </h5>
        <p>
            Tasdgfasd asdf asg q qg qg e.
        </p>   


    </div> <br> 






    <!--Navigation Menu-->
    <hr>
    <strong><u>Navigation Menu:</u></strong>
    <ul>
        <li><a href="./index.html"><p><u>Index Page</u></p></a></li>
        <li><a href="./proposal.html"><u>Project Proposal and Timeline</u></a></li>
        <li><a href="./greenhouse_monitor_project.html"><u>Arduino Wi-Fi Monitor and REST API</u></a></li>
    </ul>

</body>
</html>