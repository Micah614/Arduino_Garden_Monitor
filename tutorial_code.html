<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="javascript.js"></script>

    <title>
        Arduino Project Board Tutorial Summaries
    </title>
</head>
<body>
    <h1>
        Arduino Tutorials
    </h1>
    <!--Page Summary-->
    <p>
        Welcome to the Arduino mini-project and tutorial page. 
        
        This page includes tutorial documentation with photos, data, and Arduino source code. Each tutorial 
        section described in the summaries below describes skills and knowledge that was acquired to 
        complete the larger project of building an IOT-integrated device and REST API platform at a URL 
        related at this website. 

        Each entry in this table below outlines an experiment or observation involving single board computer 
        parts and Arduino packaged firmware. Working materials include sensors, switches, buttons, LEDs, 
        continuous control knobs, joystick, and RFID field detector, to name a few. Some of these projects are 
        from the tutorial guide, others might be designed by me. Check out the 
        <a href="./greenhouse_monitor_project.html" class="">WiFi Greenhouse Monitor and REST API Project</a> 
        for more Arduino madness!
    </p>
        

    <!--Weekly Timeline Table-->
    <table style="width:100%">
        <caption>
            Click a link in the "Time Period" column to read about that week's activities.
        </caption>
        <tr>
            <th scope="col">Time Period</th>
            <th scope="col">Activity Summary</th>
        </tr>
        <!-- Start of weekly update format-->
        <tr>
            <th scope="row">
                <a href="#week_1_and_2">
                    Week 1 and 2
                </a>
            </th>
            <td>
                <p>
                    Week one was spent defining an idea for the semester project. 
                    For more information visit the <a href="./proposal.html">Project Proposal.</a> webpage.
                </p>
                <p>
                    Week two was mainly spent developing the project proposal and starting a GitHub website URL 
                    for the semester project. I also completed the first 4 chapters of the Arduino 
                    Project Board Tutorial.
                </p>
            </td>
        </tr>
        <!-- End of weekly update format unit-->>
        <tr>
            <th scope="row">
                <a href="#week_3">
                    Week 3
                </a>
            </th>
            <td>
                In week three, I extended the project website by 3 more pages and inserted links between 
                the pages of the site. I also completed additional Arduino Project Board tutorial challenges.
            </td>
        </tr>
    </table>
    <!-- End of the inner-page navigation menu table-->


    <hr>

    <!-- Start of Weekly Summaries-->
    <div> <!-- Save this div for CSS formatting. -->
        <h4 id="week_1_and_2">
            Week 1+2: Start a GitHub Pages Website, Start Tutorial, Develop and Submit a Proposal
        </h4>
        <p>
            A large part of week 1+2 was spent developing the project proposal and crafting a project timeline. 
            Early chapters of the project board tutorial (completed in week 2) explain the basics of the Arduino 
            integrated development environment (IDE), as well as how to create, compile, push and test Arduino 
            firmware.

            The project board tutorial explains the basic concepts of driver functions, including the roles of 
            the setup() and loop() driver methods and how to use system calls to control and communicate with 
            prototype electronics via comm. hubs, electrical circuits, and free-range communication exchange 
            media (e.g., infrared, RFID, etc.).
            
            The Arduino IDE software provides a feature rich and intuitive development platform. The set up 
            involves a simple download from the official Arduino website, and choosing a folder to contain future 
            source files. The only pitfall that I encountered during this set up was an apparent incompatibility 
            of Arduino IDE generated files and the GitHub repository stored on my local computer. According to 
            the generated error messages, the GitHub repository on my local computer creates an environment that 
            is too complex for the Arduino IDE to interact with. While investigating this finding, I observed 
            that each sketch (another term for an Arduino source file) generates a number of dependency files 
            during compile time, producing a "bloat ratio" in the range of 2-3 new files for each new sketch. 
            GitHub compatiblity issues aside, the IDE software provides a great list of features including a 
            file manager, terminal shell, and editor.
            
            Programming in the Arduino dialect of C++ involves a mixture of object-oriented programming, 
            development of sys- and trap- calls, and tactful use of Arduino-defined function stems, including 
            "setup()", "loop()", and "digitalWrite()". Arduino developers are free to define helper functions of 
            any kind, subject only to the hardware constraints of the single-board the firmware is loaded on. 
        </p>

        <img src="./Images/Arduino_IDE.png"> <br> 
        <p>
            <strong>Figure 1.)</strong> Snapshot of the Arduino integrated development environment (IDE).
        </p>
        <h5>
            Chapters 1: LED Blink
        </h5>
        <p>
            Chapter one of this tutorial explains the concept of converting analog to digital signals. The 
            chapter describes the LED circuit and the role of the "setup()", "loop()", "delay()" and 
            "digitalWrite()" functions in firmware. Each of these principles is demostrated through a 
            firmware program designed to drive a blinking LED.
            
            <b>Sketch: LED_Blink</b> <br> 
            <b>/* Chapter 1 */</b> <br> 
            // the setup function runs once when you press reset or power the board <br> 
            void setup() { <br> 
              // initialize digital pin 13 as an output <br> 
              pinMode(13, OUTPUT); <br> 
            } <br> 
            // the loop function runs over and over again forever <br> 
            void loop() { <br> 
              digitalWrite(13, HIGH); // turn the LED on (HIGH is the voltage level) <br> 
              delay(1000); // wait for a second <br> 
              digitalWrite(13, LOW); // turn the LED off by making the voltage LOW <br> 
              delay(1000); // wait for a second <br> 
            } <br> 
        </p>

        <h5>
            Chapter 2: Flowing LED
        </h5>
        <p>
            Chapter 2 of this material demonstrates the object-oriented nature of firmware development by using 
            loops and basic data structures (i.e., arrays) to synchronize and control circuits of electronic 
            devices, in this case, a panel of LEDs.
            
            <b>Sketch: Flowing_LED_Display</b> <br> 
            <b>/* Chapter 2 */</b> <br> 
            const int ledCount = 14; // the number of LEDs <br> 
            // an array of pin numbers to which LEDs are attached <br> 
            int ledPins[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 }; <br> 
            void setup() { <br> 
              // loop over the pin array and set them all to output: <br> 
              for (int i = 0; i < ledCount; i++) { <br> 
                pinMode(ledPins[i], OUTPUT); <br> 
              } <br> 
            } <br> 
            void loop() { <br> 
              // the ith LED will light up in turn <br> 
              for (int i = 0; i < ledCount; i++) { <br> 
                barGraphDisplay(i); <br> 
              } <br> 
              for (int i = ledCount-1; i >=0; i--) { <br> 
                barGraphDisplay(i); <br> 
              } <br> 
            } <br> 
            void barGraphDisplay(int ledOn) { <br> 
              // make the "ledOn"th LED on and the others off <br> 
              for (int i = 0; i < ledCount; i++) { <br> 
                if (i == ledOn) <br> 
                  digitalWrite(ledPins[i], HIGH); <br> 
                else <br> 
                  digitalWrite(ledPins[i], LOW); <br> 
              } <br> 
              delay(100); <br> 
            } <br> 
        </p>

        <h5>
            Chapter 3: Control LED with a Push Button Switch
        </h5>
        <p>
            Chapter 3 of this tutorial explains the circuit fundamentals of controlling circuit behavior with a 
            button-based switch. 
            
            <img src="./Images/button_circuit_diagram.svg"> <br> 
            <img src="./Images/project_board_schematic.svg"> <br> 


            <b>Sketch: Control_LED_by_Button</b> <br> 
            <b>/* Chapter 3 - mini-project 1 */</b> <br> 
            /* This sketch maps the voltage detected on a closed circuit created by the button to an 
               LED ON state that persists as long as the button is held down. */ <br> 
            int buttonPin = 2; // the number of the push button pin <br> 
            int ledPin = 13; // the number of the LED pin <br> 
            void setup() { <br> 
              pinMode(buttonPin, INPUT); // set push button pin into input mode. (says "read the signal here.") <br> 
              pinMode(ledPin, OUTPUT); // set LED pin into output mode. (says "affect the cicuit component at this location.") <br> 
            } <br> 
            void loop() { <br> 
              if (digitalRead(buttonPin) == HIGH) // if the button is not pressed <br> 
                digitalWrite(ledPin, LOW); // switch off LED <br> 
              else // if the button is pressed <br> 
                digitalWrite(ledPin, HIGH); // switch on LED <br> 
            } <br> 

        </p>
        <h5>
            Chapter 4: Sending/Receiving Data Through a Serial Communication Port
        </h5>
        <p>
            asdfasdkgnaoiusnvoamdimap ia spodvpoa ivna voina svoi n 


        </p>
    </div>

    <div>  <!-- Save this div for CSS formatting. -->
        <h4 id="week_3">
            Week 3: Extend the Project Website, Complete Project Board Tutorials
        </h4>
        <p>
            This week covered more arduino circuit devices and transmitting instructions and data through a 
            serial communication port.
        </p>
        <h5>
            This Week's Breakdown:
        </h5>
        <ul>
            <li>
                <strong>
                    <a href="#chapter_5">Chapter 5 - Analog-to-Digital Signal Converters and Serial Comm Links.</a>
                </strong>
            </li>
            <li>
                <strong>
                    Chapter 6 - LEDPixel Driver
                </strong>
            </li>
        </ul>
    
        <h5 id="chapter_5">
            Chapter 5 - Analog-to-Digital Converters ("ADC"s) in Serial Communication
        </h5>
        <p>
            ADC is used to convert analog (the physical signal) signals into digital signals (the abstract 
            message being transmitted between electronic devices). This section of the tutorial 
            explains how this signal transformation is achieved.
        </p>
        <h5>
            Circuit Knowledge
        </h5>        
        <p> 
            An ADC is an electronic circuit used to convert analog signals such as voltage to 
            digital or binary format consisting of 0's and 1's. The range of the ADC module included in the 
            project board is 10 bits, which means the ADC circuit component carries a 2^10 = 1024 bit 
            resolution. This means that the ADC's voltage settings are evenly and reliably distributed into 
            1024 "discrete" voltages (ranging from 0 to 5V), each corresponding to a digital signal. 
        </p>
        <img src="./Images/ADC_Graph.png">
        <p>
            <strong>Figure 2.)</strong> A graphical explaination of the potentiometer-drived analog-to-digital 
            conversion, also called "ADC". The rotational potentiometer included in the project board 
            achieves 1024 unique states, each equating to a unique binary/digital output. Note the step-like 
            behavior of this function, revealing the discretized voltage ranges corresponding to each digital 
            output.
        </p>
        <p>
            This voltage setting is controlled with a circuit element called a "potentiometer", which is 
            essentially an adjustable resistor element. Potentiometers are typically controlled by a resistive 
            substance (e.g., a wire or a carbon element) and a contact brush. The resistance (and therefore 
            voltage) of the potentiometer changes depending on the placement of the contact brush. The position 
            of this contact brush is what provides the ADC with it's resolution capacity. The resistive surface 
            is divided into discrete stages for the contact brush to rest upon. It is the position of this brush 
            that effects the analog to digital signal transformation and determines the ADC's signal resolution.
        </p>
        
        <p>
            The potentiometer is the core electrical component of a turn dial knob, such as one might find in 
            an old car radio. In fact, turn dials are sometimes called "rotary potentiometers", since they 
            really just linear potentiometers with the physical action mapped to a rotational range of 
            motion. Because each voltage must be mapped to a discrete digital signal, a calculation must be 
            included in the driver code to complete the analog-to-digital signal transformation. 
        </p>
        
        <h4>Experiment/Sketch:</h4>
        <p>
            This tutorial section demonstrates the core concepts of ADC by writing a program to read the 
            current voltage of a rotary potentiometer and send this data to the IDE Serial Monitor window 
            via a serial port connection (port 4, in this case). The following section is driver code 
            collected from the tutorial.
        </p>

        <p>
            ~~~~~~<br>
            int adcValue; // Define a variable to save ADC value<br>
            float voltage; // Define a variable to save the calculated voltage value<br>
            
            void setup() {<br>
            Serial.begin(9600); // Initialize the serial port and set the baud rate to 9600<br>
            }<br>
            
            void loop() {<br>
                adcValue = analogRead(A1); // Convert analog of pin A1 to digital<br>
                voltage = adcValue * (5.0 / 1023.0);// Calculate voltage according to digital. Discretizes voltage range into 1024 bins.<br>
                <br>
                // Send the result to computer through serial port.<br>
                Serial.print("convertValue:");<br>
                Serial.println(adcValue);  // convertValue ranges from 0 to 1023<br>

                Serial.print("Voltage:");<br>
                Serial.println(voltage);  // <br>
                delay(500);  # delay between signal transmission (keeps the screen serial monitor from expanding uncontrollably)<br>
            }<br>
            ~~~~~~<br>
        </p>
    </div>

    <br>

    <!--Navigation Menu-->
    <hr>
    <strong><u>Navigation Menu:</u></strong>
    <ul>
        <li><a href="./index.html"><p><u>Index Page</u></p></a></li>
        <li><a href="./proposal.html"><u>Project Proposal and Timeline</u></a></li>
        <li><a href="./greenhouse_monitor_project.html"><u>Arduino Wi-Fi Monitor and REST API</u></a></li>
    </ul>

</body>
</html>