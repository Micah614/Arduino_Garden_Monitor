<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="javascript.js"></script>

    <title>Arduino Tutorial Summaries</title>
</head>
<body>
    <h1>Arduino Tutorials</h1>
    <!--Page Summary-->
    <p>Welcome to the Arduino mini-project and tutorial page. 
        
        This page includes tutorial documentation with photos, data, and Arduino source code. Each tutorial 
        section described in the summaries below describes skills and knowledge that was acquired to 
        complete the larger project of building an IOT-integrated device and REST API platform at a URL 
        related at this website. 

        Each entry in this table below outlines an experiment or observation involving single board computer 
        parts and Arduino packaged firmware. Working materials include sensors, switches, buttons, LEDs, 
        continuous control knobs, joystick, and RFID field detector, to name a few. Some of these projects are 
        from the tutorial guide, others may be designed by me. 
        (Note: Be sure to check out the <a href="./greenhouse_monitor_project.html" class="">WiFi Connected 
            Greenhouse Monitor and RESTful API Project</a> for more Arduino madness.) 
    </p>
        
    <!--Weekly Timeline Table-->
    <table style="width:100%">
        <tr>
          <th>Weekly Timeline</th>
          <th>Activity Summary</th>
        </tr>
        <tr>ls
            <td><a href="#week_2">Week 1</a></td>
            <td>Week one was dedicated to defining an idea for the <a href="./proposal.html">Project Proposal.</a></td>
          </tr>
        <tr>
          <td><a id="#week_2">Week 2</a></td>
          <td>Week two was mainly spent developing the project proposal and starting a GitHub website URL for the semester project. I 
            also completed the <a href="">first 4 chapters of the Arduino Project Board Tutorial.</a></td>
        </tr>
        <tr>
          <td><a id="#week_3">Week 3</a></td>
          <td>In week three, I extended the project website by 3 pages and inserted links between pages of the site.  (Arduino tutorials
            are TBD)
          </td>
        </tr>
        <tr>
            <td><a id="#week_4">Week 4</a></td>
            <td>(More Tutorials, coming soon...)</td>
        </tr>
        <tr>
            <td><a id="#week_5">Week 5</a></td> 
            <td>TBD</td>
        </tr>
    </table>
    <!-- End inner-page navigation menu table-->
    <hr>

    <!-- Begin Weekly Summaries-->
    <div>
        <h3>Week 1+2: Start a GitHub Pages Website, Submit Second Draft Proposal</h3>
        <h4><u>Tutorial Chapters:</u></h4>
        <ul>
            <li>Chapters 1&2: LED Blink/Flowing LED</li>
            <li>Chapter 3: Control LED with a Push Button Switch</li>
            <li>Chapter 4: Sending/Receiving Data Through a Serial Port</li>
        </ul>
        <h4 id="week_2"><u>Week 2 Summary</u></h4>
        <p>
            A large part of week two was spent completing the project proposal and developing the project 
            timeline, but I did manage to squeeze in a few tutorials as well. 
            
            The early chapters of the tutorial start by explaining the basics of the Arduino integrated 
            development environment (IDE), and how to create, compile, push and test C/C++ device firmware. 
            This tutorial explain the basic concepts of driver functions, including the roles of the setup() 
            and loop() driver methods and various system calls that can be used to control and communicate 
            with various circuit components. 
            
            The Arduino IDE software is an incredibly durable, intuitive, robust and reliable development 
            platform, in my opinion. The window pane layout of the Arduino IDE tool makes the purpose of 
            each tool clear to the user and using each tool is remarkably straight-forward. Simply download 
            the software on the Arduino website, and set up a folder for sketch files. The only downside that 
            I did encounter was the incompatibility of the Arduino IDE with GitHub repository monitored files.
            Apparently the GitHub environment space is too large and/or complex for the Arduino IDE to 
            interpret and work with. 
            
            Although the IDE does not require many dependencies to install, the resulting sketch files 
            create a fairly large number of dependencies, with a ratio somewhere in the range of 2-3 
            additional files for every new sketch file that is created. The IDE software comes with its' 
            own shell terminal, file manager, and text editor. Presumably at least some of these 
            dependency files contain information required by one or more of the IDE software components.  
            
            Programming in the Arduino IDE involves a mixture of C/C++ object-oriented programming, syscalls, 
            and Arduino-defined function stems (e.g., "setup()" and "loop()"). Developers are free to define 
            helper functions of any kind, subject only to the memory constraints of the single-board 
            computer the firmware is loaded on. 
            
            Week 2's tutorial material primarily discussed the manner data is sent and received across a 
            serial communication port, including communicating with a device by submitting instructions through 
            a terminal.
            Later this semester I will extract very similar time-series information from a system of my own design 
            and use it to investigate a variety of "extract-transform-load" (ETL) and "extract-load-transform" 
            (ELT) methods, including SQL based data storage, XML and JSON file formats.
        </p>

            <img src="./Images/Arduino_IDE.png">
            <p><strong>Figure 1.)</strong> Snapshot of the Arduino integrated development environment (IDE).</p>
    </div>

    <div >
        <h4 id="week_3">Week 3: Extend the Project Website, Complete Project Board Tutorials</h4>
        <p>The following tutorials were completed this week.</p>
        <h5>This Week's Breakdown:</h5>
        <ul>
            <li>Chapter 5 - Analog-to-Digital Converters</li>
            <li>Chapter 6 - ...</li>
        </ul>
    
        <h5>Chapter 5 - Analog-to-Digital Converters ("ADC"s) in Serial Communication</h5>

        <p>
            ADC is used to convert analog (the physical signal) signals into digital signals (the abstract 
            message being transmitted between electronic devices). This section of the tutorial 
            explains how this signal transformation is achieved.
        </p>
        
        <h5>Circuit Knowledge -- ADC</h5>        
        
        <p> 
            An ADC is an electronic circuit used to convert analog signals such as voltage to 
            digital or binary format consisting of 0's and 1's. The range of the ADC module included in the 
            project board is 10 bits, which means the ADC circuit component carries a 2^10 = 1024 bit 
            resolution. This means that the ADC's voltage settings are evenly and reliably distributed into 
            1024 "discrete" voltages (ranging from 0 to 5V), each corresponding to a digital signal. 
        </p>
        
        <img src="./Images/ADC_Graph.png">
        <p>
            <strong>Figure 2.)</strong> A graphical explaination of the potentiometer-drived analog-to-digital 
            conversion, also called "ADC". The rotational potentiometer included in the project board 
            achieves 1024 unique states, each equating to a unique binary/digital output. Note the step-like 
            behavior of this function, revealing the discretized voltage ranges corresponding to each digital 
            output.
        </p>
        
        <p>
            This voltage setting is controlled with a circuit element called a "potentiometer", which is 
            essentially an adjustable resistor element. Potentiometers are typically controlled by a resistive 
            substance (e.g., a wire or a carbon element) and a contact brush. The resistance (and therefore 
            voltage) of the potentiometer changes depending on the placement of the contact brush. The position 
            of this contact brush is what provides the ADC with it's resolution capacity. The resistive surface 
            is divided into discrete stages for the contact brush to rest upon. It is the position of this brush 
            that effects the analog to digital signal transformation and determines the ADC's signal resolution.
        </p>
        
        <p>
            The potentiometer is the core electrical component of a turn dial knob, such as one might find in 
            an old car radio. In fact, turn dials are sometimes called "rotary potentiometers", since they 
            really just linear potentiometers with the physical action mapped to a rotational range of 
            motion. Because each voltage must be mapped to a discrete digital signal, a calculation must be 
            included in the driver code to complete the analog-to-digital signal transformation. 
        </p>
        
        <h4>Experiment/Sketch:</h4>
        <p>
            This tutorial section demonstrates the core concepts of ADC by writing a program to read the 
            current voltage of a rotary potentiometer and send this data to the IDE Serial Monitor window 
            via a serial port connection (port 4, in this case). The following section is driver code 
            collected from the tutorial.
        </p>

        <p>
            ~~~~~~<br>
            int adcValue; // Define a variable to save ADC value<br>
            float voltage; // Define a variable to save the calculated voltage value<br>
            
            void setup() {<br>
            Serial.begin(9600); // Initialize the serial port and set the baud rate to 9600<br>
            }<br>
            
            void loop() {<br>
                adcValue = analogRead(A1); // Convert analog of pin A1 to digital<br>
                voltage = adcValue * (5.0 / 1023.0);// Calculate voltage according to digital. Discretizes voltage range into 1024 bins.<br>
                <br>
                // Send the result to computer through serial port.<br>
                Serial.print("convertValue:");<br>
                Serial.println(adcValue);  // convertValue ranges from 0 to 1023<br>

                Serial.print("Voltage:");<br>
                Serial.println(voltage);  // <br>
                delay(500);  # delay between signal transmission (keeps the screen serial monitor from expanding uncontrollably)<br>
            }<br>
        </p>
    </div>

    <hr>

    <!--Navigation Menu-->
    <hr>
    <strong><u>Navigation Menu:</u></strong>
    <ul>
        <li><a href="./index.html"><p><u>Index Page</u></p></a></li>
        <li><a href="./proposal.html"><u>Project Proposal and Timeline</u></a></li>
        <li><a href="./greenhouse_monitor_project.html"><u>Arduino Wi-Fi Monitor and REST API</u></a></li>
    </ul>

</body>
</html>