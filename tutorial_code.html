<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="javascript.js"></script>

    <title>
        Arduino Project Board Tutorial Summaries
    </title>
</head>
<body>
    <h1>
        Arduino Tutorials
    </h1>
    <!--Page Summary-->
    <p>
        Welcome to the Arduino Freenove project board tutorials page. 
        
        This page includes tutorial documentation with photos, data, and Arduino source code. Each tutorial 
        section described in the summaries below describes skills and knowledge that was acquired to 
        complete the larger project of building an IOT-integrated device and REST API platform at a URL 
        related at this website. 

        Each entry in this table below outlines an experiment or observation involving single board computer 
        parts and Arduino packaged firmware. Working materials include sensors, switches, buttons, LEDs, 
        continuous control knobs, joystick, and RFID field detector, to name a few. Some of these projects are 
        from the tutorial guide, others might be designed by me. Check out the 
        <a href="./greenhouse_monitor_project.html" class="">WiFi Greenhouse Monitor and REST API Project</a> 
        for more Arduino madness!
    </p>
        

    <!--Weekly Timeline Table-->
    <table style="width:100%">
        <caption>
            Click a link in the "Time Period" column to read about the week's activities.
        </caption>
        <tr>
            <th scope="col">Time Period</th>
            <th scope="col">Activity Summary</th>
        </tr>
        <!-- Start of weekly update format-->
        <tr>
            <th scope="row">
                <a href="#week_1_and_2">
                    Week 1 and 2
                </a>
            </th>
            <td>
                <p>
                    Week one was spent defining an idea for the semester project. 
                    For more information visit the <a href="./proposal.html">Project Proposal.</a> webpage.
                </p>
                <p>
                    Week two was mainly spent developing the project proposal and starting a GitHub website URL 
                    for the semester project. I also completed the first 4 chapters of the Arduino 
                    Project Board Tutorial.
                </p>
            </td>
        </tr>
        <!-- End of weekly update format unit-->
        <tr>
            <th scope="row">
                <a href="#week_3">
                    Week 3
                </a>
            </th>
            <td>
                In week 3, I extended the project website by 3 more pages and inserted links between 
                the pages of the site. I also completed additional Arduino Project Board tutorial challenges.
            </td>
        </tr>
        <tr>
            <th scope="row">
                <a href="#week_4">
                    Week 4
                </a>
            </th>
            <td>
                Tutorial Chapter 6 - RGB LED, and discoveries about project REST API configuration options.
            </td>
        </tr>
        <tr>
            <th scope="row">
                <a href="#week_5">
                    Week 5
                </a>
            </th>
            <td>
                Lorem Ipsum.
            </td>
        </tr>
    </table>
    <!-- End of the inner-page navigation menu table-->


    <hr> <!-- BEGIN WEEK 1 + 2 -->

    <!-- Start of Weekly Summaries-->
    <div> <!-- Save this div for CSS formatting. -->
        <h4 id="week_1_and_2">
            Week 1+2: Start a GitHub Pages Website, Start Tutorial, Develop and Submit a Proposal
        </h4>
        <p>
            A large part of week 1+2 was spent developing the project proposal and crafting a project timeline. 
            Early chapters of the project board tutorial (completed in week 2) explain the basics of the Arduino 
            integrated development environment (IDE), as well as how to create, compile, push and test Arduino 
            firmware.

            The project board tutorial explains the basic concepts of driver functions, including the roles of 
            the setup() and loop() driver methods and how to use system calls to control and communicate with 
            prototype electronics via comm. hubs, electrical circuits, and free-range communication exchange 
            media (e.g., infrared, RFID, etc.).
            
            The Arduino IDE software provides a feature rich and intuitive development platform. The set up 
            involves a simple download from the official Arduino website, and choosing a folder to contain future 
            source files. The only pitfall that I encountered during this set up was an apparent incompatibility 
            of Arduino IDE generated files and the GitHub repository stored on my local computer. According to 
            the generated error messages, the GitHub repository on my local computer creates an environment that 
            is too complex for the Arduino IDE to interact with. While investigating this finding, I observed 
            that each sketch (another term for an Arduino source file) generates a number of dependency files 
            during compile time, producing a "bloat ratio" in the range of 2-3 new files for each new sketch. 
            GitHub compatiblity issues aside, the IDE software provides a great list of features including a 
            file manager, terminal shell, and editor.
            
            Programming in the Arduino dialect of C++ involves a mixture of object-oriented programming, 
            development of sys- and trap- calls, and tactful use of Arduino-defined function stems, including 
            "setup()", "loop()", and "digitalWrite()". Arduino developers are free to define helper functions of 
            any kind, subject only to the hardware constraints of the single-board the firmware is loaded on. 
        </p>

        <img src="./Images/Arduino_IDE.png"> <br> 

        <p>
            <strong>Figure 1.)</strong> Snapshot of the Arduino integrated development environment (IDE).
        </p>
        <h5>
            Chapter 1: LED Blink
        </h5>
        <p>
            Chapter one of this tutorial explores the fundamental concepts of converting analog to digital signals. This introductory 
            chapter also describes the role of the "setup()", "loop()", "delay()" and "digitalWrite()" functions in Arduino firmware. 
            The first lesson combines these three simple functions to generate a program to drive a blinking LED. <br> <br>
        </p>

        <h5>
            Chapter 2: Flowing LED
        </h5>
        <p>
            Chapter 2 of this material demonstrates the object-oriented nature of firmware development by explaining the basic 
            loops and data structures (i.e., arrays) needed to synchronize and control devices on electronic circuits, in this case, a 
            sequence of LEDs on the Freenove project board. <br> <br> 
            <img src="./Images/Flowing_LED_Display.jpg">
        </p>

        <h5>
            Chapter 3: Control LED with a Push Button Switch
        </h5>
        <p>
            Chapter 3 of this tutorial explains the circuit fundamentals of controlling circuit behavior with a 
            button-based switch. 
        </p>
        
        <img src="./Images/button_circuit_diagram.svg"> <br> 
        
        <p>
            <strong>Figure 2.)</strong> A diagram of a button-controlled circuit.
        </p>
        <p>
            The first sub-section of this chapter discusses how the voltage state of the circuit in figure 3 
            can be encoded as a meaningful signal state by applying the firmware to the control board set to 
            the configuration shown in figure 3. <br> <br> 
        </p>
        
        <img src="./Images/Control_LED_by_Button.jpg"> <br>

        <p>
            The second sketch design maintains the "ON" or "OFF" state of the LED subcircuit until the button 
            is pressed again. This is commonly referred to as programming a "persistant state" in the controller. 
            Included in the circuit knowledge of this chapter is a discussion about controlling "bounce" in 
            electrical cicuits. Bounce is a phenomena created by micro-imbalances in the electrical signal prior 
            to achieving a maintainable state. Controlling bounce essentially involves inoking a delay prior to 
            the interpretation of an electrical state signal. If bounce is left uncontrolled by the device 
            firmware, the state of the controlling device (i.e., button) is read during a period of oscillation, 
            causing the firmware to react rapidly to the perceived ON/OFF state detected in the circuit. <br> <br> 
        </p>
        <p>
            We can see how this sleep-like system call is applied in the driver firmware by reading the sketch 
            code snippet below. <br> <br> 
        </p>
        <img src="./Images/Control_LED_State_by_Button.jpg">

        <h5>
            Chapter 4: Sending/Receiving Data Through a Serial Communication Port (AKA "Comm. Port")
        </h5>
        <p>
            Chapter 4 discusses the basics of serial communication (AKA "Universal Asynchronous Receiver/Transmitter (UART)") protocols, 
            in which two communicating devices claim designated transmitting and receiving ports used to communicate with another device 
            or intercept signals on a network it connects with. The code knowledge of this section explains the role of interruption 
            programs (AKA "system calls") in collecting asynchronous feedback from connected or communicating devices. This 
            block quote from the tutorial provides a good analogy for the subject: <br> 
            <blockquote>
                ...suppose you're watching TV while there is water heating in your kitchen... (without a teakettle spout) you have to 
                check whether the water is boiling or not from time to time, so you can't concentrate on watching TV. But (with) an 
                interrupt, things are different. Interrupts work much like the lid on your teakettle, ... it whistles when the water is 
                beginning to boil ... so you can focus on watching TV ..."
            </blockquote>
            The role of the interrupt program is to allow the processor to facilitate the execution of as many tasks (or programs) as 
            possible while conserving computational resources.
        </p>
        <p>
            The following source code sets up a 9600 Baud rate communication speed between the terminal and board, then prints a rolling 
            script prompt. When a user types a message into the terminal, the message is received by the control board, which echoes it 
            back to the terminal. The terminal prints the response quickly and immediately resumes counting. This simple two-way 
            communication demonstrates the core concept of asynchronous serial communication.
        </p>
        <img src="./Images/Receive_Data_Through_Serial_Port.jpg">
    </div>

    <hr> <!-- BEGIN WEEK 3 -->

    <div>  <!-- Save this div for CSS formatting. -->
        <h4 id="week_3">
            Week 3: Extend the Project Website, Complete Tutorials
        </h4>
        <h5>
            Chapter 5: Analog-to-Digital Converters ("ADC"s) in Serial Communication
        </h5>
        <p> 
            An ADC is an electronic circuit used to convert analog signals such as voltage to 
            digital or binary format consisting of 0's and 1's. The range of the ADC module included in the 
            project board is 10 bits, which means the ADC circuit component carries a 2^10 = 1024 bit 
            resolution. This means that the ADC's voltage settings are evenly and reliably distributed into 
            1024 "discrete" voltages (ranging from 0 to 5V), each corresponding to a digital signal. 
        </p>
        <img src="./Images/ADC_Graph.png">
        <p>
            <strong>Figure 2.)</strong> A graphical explaination of the potentiometer-driven analog-to-digital 
            converter, also known as "ADC", principles. The rotational potentiometer included in the project board 
            achieves 1024 unique states, each equating to a unique binary/digital output. Note the step-like 
            behavior of this function, revealing the discretized voltage ranges corresponding to each digital 
            output.
        </p>
        <p>
            This voltage setting is controlled with a circuit element called a "potentiometer", which is 
            essentially an adjustable resistor element. Potentiometers are typically controlled by a resistive 
            substance (e.g., a wire or a carbon element) and a contact brush. The resistance (and therefore 
            voltage) of the potentiometer changes depending on the placement of the contact brush. The position 
            of this contact brush is what provides the ADC with it's resolution capacity. The resistive surface 
            is divided into discrete stages for the contact brush to rest upon. It is the position of this brush 
            that effects the analog to digital signal transformation and determines the ADC's signal resolution.
        </p>
        <p>
            The potentiometer is the core electrical component of a turn dial knob, such as one might find in 
            an old car radio. In fact, these turn dials are sometimes called "rotary potentiometers", since they 
            really just linear potentiometers with the physical action mapped to a rotational range of 
            motion. Because each voltage must be mapped to a discrete digital signal, a transformation is 
            included in the driver to break the 5.0V range into 1024 distinct voltage gaps, completing the 
            analog-to-digital (ADC) transformation. 
        </p>
        <p>
            This tutorial section demonstrates the core concepts of ADC by writing a program to read the 
            current voltage of a rotary potentiometer and send this data to the IDE Serial Monitor window 
            via a serial port connection (port 4, in this case). The following section is driver code 
            collected from the tutorial.
        </p>

        <img src="./Images/ADC_Read_Voltage.jpg"> <br> <br> 

        <hr> <!-- BEGIN WEEK 4 -->

        <h4 id="week_4">
            Week 4: Extend the Project Website, Complete Tutorials
        </h4>
        <h5>
            Chapter 6 - RGB LED
        </h5>
        <p>
            Chapter 6 integrates topics from the previous chapters into a fun mini-project to control a 3-color LED with a 
            3-knob potentiometer dials. The idea is that the different colors of light (red, green, and blue) mix together and emit a 
            special color that the user can adjust. This exercise involves the mapping of potentiometer states to a LED output in 3 
            separate channels.
        </p>   

        <video width="320" height="240" controls>
            <source src="./Videos/RGB_LED.mp4" type="video/mp4">
            <source src="./Videos/RGB_LED.mp4"  type="video/ogg">
          Your browser does not support the video tag.
          </video>

        <p>
            Interestingly, this set of RGB dials can be used to generate precise RGB values (which can be relayed to the terminal) 
            for front-end development tasks that require specific RGB color values. I may very well use this sketch to select the colors 
            of my upcoming CSS designs. The video above does not do it justice, however this program is capable of generating 
            samples of some estimated 1,073,741,824 RGB color shades!

            Since each of the three knobs contain 1024 unique voltage states, with each of these controlling the relative intensity of 
            its' associated LED (i.e., red, green, or blue), the number of unique colors is tremendous, producing something on the order of
            1024<sup>3</sup> unique color combinations. 
            
            As a side note, it appears that once a sketch has been loaded on the control board, the program continues to run interrupted 
            with no discernable support from any desktop computing resources. Recall that this is indeed true, since the control board 
            provides it's own computational circuit, main memory, and processing resources! This means that aside from streaming data 
            over the port it is connected to, control board needs only a local source of power. All of this is quite convenient for the 
            sensors we will try to develop in <a href="./greenhouse_monitor_project.html">part 2</a> of this project.
        </p>
        <h5>
            Project Research
        </h5>
        <p>
            This week I completed some research on the software methods and tools that I will need to configure the REST API Greenhouse 
            Monitor Project in the upcoming weeks. 
        </p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/dWM4p_KaTHY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen, id="arduino_server_youtube_video"></iframe>

        <hr> <!-- BEGIN WEEK 5 -->

        <h4 id="week_5">
            Week 5: Extend the Project Website, Complete Project Board Tutorials
        </h4>
        <h5>
            Week 5 Summary: Tutorial Chapter 7 - LEDPixel
        </h5>
        <p>
            Unfortunately, due to the high volume of demonstrations in this tutorial, I will need to conclude the tutorial section of the 
            semester project by summarizing the exercises that appear most relevant to the project goals this week, and then possibly 
            conclude by matching the hardware I have on hand with the <a href="#arduino_server_youtube_video">youtube video</a> that I 
            found last week about creating a webserver from an arduino single board computer a thumbdrive or SSD partition fitted with 
            an (SQLite?) database. 
            
            The idea (of course) is to develop basic firmware programs to drive the sensors of interest to my garden 
            project. 
        </p>   
        <img src="./Images/LEDPixel_lib_manager.jpg">
        <p>
            One important topic we will need to summarize this week is how to use the Library Manager of the Arduino IDE. The Library 
            Manager is available under the "Sketch" tab. The feature is presented much like a package or widget installer with a trie-based 
            search engine that retrieves libraries by name, making them available for "lazy loading" of the library in future sketches.            use them. 
        </p>

        <h5>
            Chapter 12 - Temperature Sensor
        </h5>
        <p>
            This week, we move jump forward to investigate handling of sensor data, beginning with a simple sensor relay involving a thermistor 
            unit (attached to the project board). Chapter 12 discusses the physical concepts behind common thermocouples and the equations necessary to interpret signals from 
            these monitors. The sketch includes several equations for ADC transformation with temperature unit conversions. 
            The program sends this transformed sensor data to the terminal window at a pre-selected frequency. 
            
            This task is a good introduction to the next task at hand namely, the <b><i>extraction, aggregation, and storage of temporal 
            sensor data</i></b> we need to send to the REST API. Eventually, we want this greenhouse monitor to relay data from multiple 
            sensors, and so we will need to develop some new data processing techniques.  
        </p>

        <h5>
            Chapter 18 - LCD1602 (Display a String, I2C LCD1602 Clock)
        </h5>
        <p>
            CANCELLED, due to time constaints.
        </p>

        <h5>
            Research and Discovery
        </h5>
        <p>
            I realized this week that I need to purchase at least one 
            <a href="https://www.google.com/search?q=arduino+breadboard&tbm=isch&ved=2ahUKEwj2k7SY-Nf_AhVHBDQIHVv6AX8Q2-cCegQIABAA&oq=arduino+bread&gs_lcp=CgNpbWcQARgAMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDoHCAAQigUQQzoGCAAQCBAeOggIABCABBCxA1CxCFiVDWCsFmgAcAB4AIABiAOIAcQGkgEFNS4zLTGYAQCgAQGqAQtnd3Mtd2l6LWltZ8ABAQ&sclient=img&ei=3syUZPasGseI0PEP2_SH-Ac&bih=794&biw=1164&rlz=1C1SQJL_enUS923US924">breadboard</a>
            this week to start assembling my own circuits and sketch code next week. This observation occurred while looking for a place to 
            connect a DS18B20 temperature probe in place of the thermistor. Breadboards are cheap (roughly $6) and easy to purchase online 


             
            I have very likely underestimated the it will take to complete other tasks in this project, so I better get started.
            
            Online tutorials like 
            <a href="https://lastminuteengineers.com/multiple-ds18b20-arduino-tutorial/" >this one</a>  have assisted me in selecting 
            the appropriate parts. I also learned that so-called "breadboards" are one of the most common means of assembling circuits in 
            Arduino devices.
        </p>

        <!-- <img src="./Videos/IDE_Overview_Temperature_Probe_Discovery.mp4"></div> -->
        <iframe width="560" height="315" src="./Videos/IDE_Overview_Temperature_Probe_Discovery.mp4" title="Arduino IDE Overview / Thermistor experiment" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen, id="arduino_IDE_video"></iframe>


        <img src="./Images/arduino_breadboard.jpg">
        <img src="./Images/RAB_Holder.jpg">
        <img src="./Images/breadboard_and_bracket_invoice.jpg">

        <h2>
            See you at the <a href="./greenhouse_monitor_project.html">Greenhouse Monitor Project Page</a>!
        </h2>

    </div>
<br> <br> 
    <!--Navigation Menu-->
    <hr>
    <strong><u>Navigation Menu:</u></strong>
    <ul>
        <li><a href="./index.html"><p><u>Index Page</u></p></a></li>
        <li><a href="./proposal.html"><u>Project Proposal and Timeline</u></a></li>
        <li><a href="./greenhouse_monitor_project.html"><u>Arduino Wi-Fi Monitor and REST API</u></a></li>
    </ul>

</body>
</html>